c-----------------------------------------------------------------------
      include 'rom.f'
c-----------------------------------------------------------------------
      subroutine uservp (ix,iy,iz,eg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      integer e,f,eg
c     e = gllel(eg)

      udiff =0.
      utrans=0.
      return
      end
c-----------------------------------------------------------------------
      subroutine userf  (ix,iy,iz,eg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      integer e,f,eg
c     e = gllel(eg)

c     Note: this is an acceleration term, NOT a force!
c     Thus, ffx will subsequently be multiplied by rho(x,t).

      ffx = 0.0
      ffy = 0.0
      ffz = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine userq  (ix,iy,iz,eg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      integer e,f,eg
c     e = gllel(eg)

      qvol   = 0.0
      source = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine userchk

      include 'SIZE'
      include 'SOLN'
      include 'MOR'
      include 'GEOM'

      parameter (lt=lx1*ly1*lz1*lelt)

      common /scrusr/ t1(lt),vxe(lt),ue(0:nb)

      n=lx1*ly1*lz1*nelv

      call rom_setup_heat
      call rzero(u,(nb+1)*3)
      u(0,1)=1.
      u(1,1)=1.

      one=1.
      pi=4.*atan(one)

      ad_nsteps=1000
      ad_iostep=ad_nsteps/100
      ad_dt=2./real(ad_nsteps)

      ifrecon=.true.
      cx=ub(1,0)
      cy=vb(1,0)
      call rzero(t1,n)

      do i=1,ad_nsteps
         time=real(i)*ad_dt

         call recon(vx,vy,vz,u)

         do j=1,n
            x=xm1(j,1,1,1)
            y=ym1(j,1,1,1)
            et=exp(-8.*time*pi**2./ad_re)
            vxe(j)=et*sin(2*pi*(x-cx*time))*sin(2*pi*(y-cy*time))
         enddo

         mio=nio
         nio=-1
         call proj2bases(ue,vxe,t1,t1)
         nio=mio

         call rom_step_heat
         if (i.le.3) call copy(u,ue,nb+1)
         do j=1,1
            write (6,1) j,u(j,1),ue(j),abs(u(j,1)-ue(j))/abs(ue(j))
         enddo
         ad_step=ad_step+1
      enddo

    1 format('eu(',i1,')=',2x,1p3e12.4)

      call exitt0

      return
      end
c-----------------------------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,ieg)

      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      ux=0.0
      uy=0.0
      uz=0.0
      temp=0.0

      eps = 1.e-5
      y0 = 1.

      if (y.gt.(y0-eps)) ux = (1.-x*x)**2

      return
      end
c-----------------------------------------------------------------------
      subroutine useric (ix,iy,iz,ieg)

      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      common /ldcpar/ dxmin

      ux=0.0
      uy=0.0
      uz=0.0
      temp=0.0

      eps = 1.e-5
      y0 = 1.

      if (y.gt.(y0-eps)) ux = (1.-x*x)**2

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat

      include 'SIZE'
      include 'TOTAL'

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2

      include 'SIZE'
      include 'TOTAL'

      call rescale_x(xm1,0.,1.)
      call rescale_x(ym1,0.,1.)

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat3

      include 'SIZE'
      include 'TOTAL'

      return
      end
c-----------------------------------------------------------------------
