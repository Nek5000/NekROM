c-----------------------------------------------------------------------
c
c     This usr file originated from the Orr-Sommerfeld study presented
c     in the Overlapping Schwarz paper [P.F. Fischer, JCP 133 1997].
c
c     Here it's modified to take either re7000 or re7500 eigenfunction
c     input generated by the author's OS code.
c
c-----------------------------------------------------------------------
      subroutine uservp (ix,iy,iz,iel)
      include 'SIZE'   
C     include 'TSTEP'  
      include 'TOTAL'  
      include 'NEKUSE' 

      udiff =0.
      utrans=0.
      return
      end
c-----------------------------------------------------------------------
      subroutine userf  (ix,iy,iz,iel)
      include 'SIZE'   
      include 'TSTEP'  
      include 'INPUT'  
      include 'NEKUSE' 

      visc=param(2)
      ffx = 2.0*visc
      ffy = 0.0
      ffz = 0.0
                                                                               
      return
      end
c-----------------------------------------------------------------------
      subroutine userq  (ix,iy,iz,iel)
      include 'SIZE'   
      include 'TOTAL'  
      include 'NEKUSE' 

      qvol   = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,iel)
      return
      end   
c-----------------------------------------------------------------------
      subroutine useric (ix,iy,iz,iel)
      include 'SIZE'   
      include 'TSTEP'  
      include 'INPUT'  
      include 'GEOM' 
      include 'NEKUSE' 

      common /corrsom/ Yvec(65),uvec(65,4),work(65,4)
      common /rorrsom/ alpha,omega,eps,vmaxi
      real uo(4)

      integer icalld
      save    icalld
      data    icalld/0/

      logical ifre7k

      re = 1./param(2)
                              ifre7k = .true.    ! Assume Re=7000
      if (abs(re-7000.).gt.1) ifre7k = .false.   ! Assume Re=7500


      if (icalld.eq.0) then

         icalld=1

c        This is the output for orrsom_new 7000 1 0 2
c
c           PREDICTED 2-D GROWTH   1.7153918021465906E-003
c           PREDICTED 2-D FREQCY   0.2529293654579600     
c
c        Follow 7000 1 0 2 with  7000 1 0 1 to generate the perturbation field
c
 
         if (ifre7k) then

           alpha = 1.7153918021465906E-003  ! these are the Re=7000 numbers obtained
           omega = 0.2529293654579600       ! via:   orrsom_new < 7000 1 0 2
           open(unit=44,file='re7000.dat',status='old') ! read in the OS results

         else

           alpha = 0.2234975649E-02         ! these are the Re=7500 numbers obtained
           omega = 0.2498915356E+00         ! via:  orrsom_new < 7500 1 0 2
           open(unit=44,file='re7500.dat',status='old') ! read in the OS results

         endif

         vmax=0.0   ! For scaling
         do i=1,65

            read(44,*) Yvec(i),(uvec(i,k),k=1,4)
            Yvec(i)=Yvec(i)-1.0
            v2=uvec(i,3)**2+uvec(i,4)**2
            vmax=max(vmax,v2)

         enddo

         vmax=sqrt(vmax)
         vmaxi=1.0/vmax
         if (nid.eq.0) write(6,*) 'vmax:',vmax
         eps=param(80)*vmaxi

      endif

      call orrsom(uo,y)

      s=eps*sin(x)
      c=eps*cos(x)

      ux = c*uo(1)-s*uo(2)
      uy = c*uo(3)-s*uo(4)
      uz = 0.0

      ux = ux + (1.0-y**2)  ! Add base flow (or not)

      return
      end   
c-----------------------------------------------------------------------
      subroutine orrsom(uo,y)

      common /corrsom/ yvec(65),uvec(65,4),work(65,4)
      real uo(1)

      n=65
      m=4
      call lagrng(uo,y,yvec,uvec,work,n,m)

      return
      end
c-----------------------------------------------------------------------
      subroutine lagrng(uo,y,yvec,uvec,work,n,m)

      real uvec(n,m),yvec(n),uo(m),work(n)

      integer icalld
      save    icalld
      data    icalld /0/

      if (icalld.eq.0) then
         icalld=1
c        Initialize denominators for Lagrangian interpolant
         do i=1,n
            work(i)=prod(i,yvec(i),yvec,n)
         enddo
      endif

      call rzero(uo,m)
      do i=1,n          !     Compute Lagrangian interpolant for Uout(k)
         t=prod(i,y,yvec,n)/work(i)
         do K=1,m
            uo(k)=uo(k)+T*uvec(i,k)
         enddo
      enddo

      return
      end
c-----------------------------------------------------------------------
      FUNCTION PROD(K,X,Xvec,N)
      DIMENSION Xvec(1)
C
      T=1.0
      DO 10 I=1,K-1
         T=T*(X-Xvec(I))
   10 CONTINUE
      DO 20 I=K+1,N
         T=T*(X-Xvec(I))
   20 CONTINUE
      Prod=T
      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2
      include 'SIZE'
      include 'TOTAL'


      x0 = 0
      x1 = 2*pi
      call rescale_x(xm1,x0,x1) ! Make certain coordinates are on [0,2pi]

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat3
      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat
      return
      end
c-----------------------------------------------------------------------
      subroutine userchk

      include 'SIZE'  
      include 'TOTAL' 
      include 'MOR'

      parameter (lt=lx1*ly1*lz1*lelt)

      common /snsl2/ el2, fl2
      common /uchk/ fd(ldim),px(lt),py(lt),pz(lt)

      real rk(lt,3)

      n=lx1*ly1*lz1*nelt

      do i=1,n
         y=ym1(i,1,1,1)
         u0 = 1.0-y**2
c        u2(i) = (vx(i,1,1,1)-u0)**2 + vy(i,1,1,1)**2
         ub(i,0)=u0
         vb(i,0)=0.
      enddo

      nbavg=lb

c     call copy(tb,t,n)

      param(170)=-1.
      ifflow=.false.
      call rom_update

      call exitt0

      return
      end
c-----------------------------------------------------------------------
      subroutine uexact(ux,uy,uz,time_in)
c
      include 'SIZE'   
      include 'TSTEP'  
      include 'INPUT'  
      include 'GEOM' 
c
      real ux(1),uy(1),uz(1)
C
      common /corrsom/ Yvec(65),uvec(65,4),work(65,4)
      common /rorrsom/ alpha,omega,eps,vmaxi
      real uo(4)
C
C
      ntot = nx1*ny1*nz1*nelv
      ampt = exp(alpha*time_in)
c     write(6,*) 'ampt:',ampt,time_in
      do i=1,ntot
         x = xm1(i,1,1,1)
         y = ym1(i,1,1,1)
         call orrsom(uo,y)
C
         s=eps*sin(x-omega*time_in)*ampt
         c=eps*cos(x-omega*time_in)*ampt
C
         ux(i) = (1.0-y**2) + c*uo(1)-s*uo(2)
         uy(i) =            + c*uo(3)-s*uo(4)
         uz(i) = 0.0
      enddo
C
      return
      end   
c-----------------------------------------------------------------------
      subroutine uerror(ux,uy,uz,time_in)
c
      include 'SIZE'   
      include 'TSTEP'  
      include 'INPUT'  
      include 'GEOM' 
      include 'SOLN' 
c
      real ux(1),uy(1),uz(1)
C
      common /corrsom/ Yvec(65),uvec(65,4),work(65,4)
      common /rorrsom/ alpha,omega,eps,vmaxi
      real uo(4)
C
C
      ntot = nx1*ny1*nz1*nelv
      ampt = exp(alpha*time_in)
c     write(6,*) 'ampt:',ampt,time_in
      do i=1,ntot
         x = xm1(i,1,1,1)
         y = ym1(i,1,1,1)
         call orrsom(uo,y)
C
         s=eps*sin(x-omega*time_in)*ampt
         c=eps*cos(x-omega*time_in)*ampt
C
         ux(i) = (1.0-y**2) + c*uo(1)-s*uo(2) - vx(i,1,1,1)
         uy(i) =            + c*uo(3)-s*uo(4) - vy(i,1,1,1)
         uz(i) = 0.0
      enddo
C
      return
      end   
c-----------------------------------------------------------------------
      subroutine rom_userchk

      include 'SIZE'  
      include 'TOTAL' 
      include 'AVG'
      include 'MOR'

      parameter (ltot1=lx1*ly1*lz1*lelt)
      common /SCRNS/ u2(ltot1),ux(ltot1),uy(ltot1),uz(ltot1)
      common /rorrsom/ alpha,omega,eps,vmaxi
      common /scrsetf/ wk1(ltot1),wk2(ltot1),wk3(ltot1),wk(lb+1)

      logical ifexist
C
      real    eto,timeo,e0,et
      save    eto,timeo,e0,et
c
      integer icalld
      save    icalld
      data    icalld/0/

      ntot =nx1*ny1*nz1*nelv

      if (icalld.eq.0) then
         if (rmode.eq.'ON '.or.rmode.eq.'CP ') then
            inquire (file='ops/rf',exist=ifexist)
            if (ifexist) call read_serial(rf,nb,'ops/rf ',wk,nid)
         else
            call copy(fx,bm1,ntot)
            call cmult(fx,2.0,ntot)
            call rzero(fy,ntot)
            call rzero(fz,ntot)

            ! Construct body force operator by
            ! integrating test function with body force
            call rzero(rf,nb)
            do i=1,nb
               rf(i)=glsc2(ub(1,i),fx,ntot)+glsc2(vb(1,i),fy,ntot)
               if (ldim.eq.3) rf(i)=rf(i)+glsc2(wb(1,i),fz,ntot)
               if (nio.eq.0) write (6,*) rf(i),i,'rf'
            enddo
            call dump_serial(rf,nb,'ops/rf ',nid)

            ! Verify that the body force is 2
            call opcopy(wk1,wk2,wk3,fx,fy,fz)
            call opbinv1(wk1,wk2,wk3,wk1,wk2,wk3,1.)
            iftmp=ifxyo
            ifxyo=.true.
            call outpost(wk1,wk2,wk3,pavg,tavg,'fff')
            ifxyo=iftmp
         endif
      endif

c     n=nx1*ny1*nz1*nelv
c     do i=1,n
c        y = ym1(i,1,1,1)
c        ux(i) = 1-y*y
c        uy(i) = 0
c        vx(i,1,1,1) = vx(i,1,1,1) - ux(i)
c     enddo
c     call outpost(ux,uy,vz,pr,t,'   ')  ! base field
c     call outpost(vx,vy,vz,pr,t,'   ')  ! perturbation field
c     call exitti ('quit userchk to dump perturbation field',nelv)
 
      icalld=icalld+1
c     if (istep.le.5) call uexact(vx,vy,vz,time)

      do 110 i=1,ntot
         y=ym1(i,1,1,1)
         u0 = 1.0-y**2
         u2(i) = (vx(i,1,1,1)-u0)**2 + vy(i,1,1,1)**2
  110 continue

      if (ad_step.gt.0) then
         eto = et
c        et  = glsc2(u2,bm1,ntot)
         et  = vlsc2(u(1),u(1),nb)
      else
c        et  = glsc2(u2,bm1,ntot)
         et  = vlsc2(u(1),u(1),nb)
         eto = et
         e0  = et
         timeo = time
         write(6,*) 'chk0:',istep,icalld,time,e0
         return
      endif
 
      et0 = et/e0
      ex0 = exp(2.*alpha*time)
      er0 = et0-ex0

c     Compute current growth rate
      ratio=Et/Eto
      ratio=log(ratio)
      tdelta=time-timeo
      timeo=time
      gg=0.5*ratio/tdelta

c     compute total energy growth (long time avg)
      ratio=Et0
      ratio=log(ratio)
      g0=0.5*ratio/time

      err  = abs(gg-alpha)/abs(alpha)

c     if (nid.eq.0) write(6,*) et,eto,e0,' es'
      if (nid.eq.0) write(6,121) time,ad_step,gg,g0,et0,ex0,er0,err
  121 format(1pe13.6,I6,6e16.8,' egn')

       ntot = nx1*ny1*nz1*nelv
       umaxx = glmax(vx,ntot)
       if (umaxx.gt.10) then
          write(6,*) nid,' umax:',umax,ntot
          call emerxit
       endif

       return
       end
c-----------------------------------------------------------------------
      subroutine rom_userbases

      include 'SIZE'
      include 'TOTAL'
      include 'MOR'

      return
      end
c-----------------------------------------------------------------------
      subroutine rom_userfop

      include 'SIZE'
      include 'TOTAL'
      include 'MOR'

      return
      end
c-----------------------------------------------------------------------
      subroutine rom_userrhs(rom_rhs)

      include 'SIZE'
      include 'TOTAL'
      include 'MOR'

      real rom_rhs(lb)

      if (ifrom(1)) then
         call add2s2(rom_rhs,rf,param(2),nb)
      endif

      return
      end
c-----------------------------------------------------------------------
